package main

import (
	"bytes"
	"compress/zlib"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/Gophercraft/core/format/dbc/dbd"
	"github.com/cybriq/gotiny"
)

func handle(err error) {
	if err != nil {
		panic(err)
	}
}

func goifytype(tn string) string {
	typename := []rune(tn)
	if unicode.IsUpper(typename[0]) {
		typename[0] = unicode.ToUpper(typename[0])
	}
	tn = string(typename)
	return strings.Replace(tn, "-", "_", -1)
}

func putWarning(wr io.Writer) {
	fmt.Fprintf(wr, "// Code generated by gcraft_packdbdefs. DO NOT EDIT.\n")
}

func main() {
	dbfolder := filepath.Join("format", "dbc", "dbdefs")

	p := filepath.Join(dbfolder, "packed_definitions_autogen.go")
	ep := filepath.Join(dbfolder, "entities.go")
	file, err := os.Create(p)
	handle(err)
	putWarning(file)

	entfile, err := os.Create(ep)
	handle(err)
	putWarning(entfile)
	fmt.Fprintf(entfile, "package dbdefs\n")
	fmt.Fprintf(entfile, "import (\n")
	fmt.Fprintf(entfile, "\"github.com/Gophercraft/core/i18n\"\n")
	fmt.Fprintf(entfile, ")\n")

	fmt.Fprintf(file, "package dbdefs\n")

	// fmt.Fprintf(file, "import (\n")
	// fmt.Fprintf(file, "\"github.com/Gophercraft/core/format/dbc/dbd\"\n")
	// fmt.Fprintf(file, "\"github.com/Gophercraft/core/vsn\"\n")
	// fmt.Fprintf(file, ")\n")
	fmt.Fprintf(file, "\n")
	fmt.Fprintf(file, "var packedDefinitions = []byte {\n")

	defs := []string{
		".",
		"format",
		"dbc",
		"WoWDBDefs",
		"definitions",
		"",
	}

	folder := strings.Join(defs, string(os.PathSeparator))

	list, err := ioutil.ReadDir(folder)
	handle(err)

	var alldefs []*dbd.Definition

	var defmap map[string]*dbd.Definition
	defmap = make(map[string]*dbd.Definition, len(list))

	for _, lfile := range list {
		fp := strings.Split(lfile.Name(), ".")[0]

		fmt.Println("Opening", lfile.Name())
		deff, err := os.Open(folder + lfile.Name())
		handle(err)

		def, err := dbd.DecodeDefinition(fp, deff)
		handle(err)

		deff.Close()

		alldefs = append(alldefs, def)
		defmap[strings.ToLower(def.Name)] = def
	}

	// sort.Slice(alldefs, func(i, j int) bool {
	// 	return alldefs[i].Name < alldefs[i].Name
	// })

	for _, def := range alldefs {
		// Generate multi-version entity structure
		fmt.Fprintf(entfile, "type Ent_%s struct {\n", goifytype(def.Name))
		for _, col := range def.Columns {
			if !col.Verified {
				continue
			}

			typename := ""

			bits := col.HintBits
			switch col.Type {
			case dbd.Int:
				typename = "int64"
				if bits > 0 {
					typename = fmt.Sprintf("int%d", bits)
				}
			case dbd.Uint:
				typename = "uint64"
				if bits > 0 {
					typename = fmt.Sprintf("uint%d", bits)
				}
			case dbd.Float:
				typename = "float32"
				if bits > 0 {
					typename = fmt.Sprintf("float%d", bits)
				}
			case dbd.Bool:
				typename = "bool"
			case dbd.String:
				typename = "string"
			case dbd.LocString:
				typename = "i18n.Text"
			default:
				panic(col.Type)
			}

			if col.HintArray {
				typename = "[]" + typename
			}

			fmt.Fprintf(entfile, "%s %s\n", col.Name, typename)
		}
		fmt.Fprintf(entfile, "}\n")
	}

	var compressedDefs bytes.Buffer

	defWriter := zlib.NewWriter(&compressedDefs)
	// gotiny.NewEncoder().Encode(&defWriter)
	gobig := gotiny.Marshal(&defmap)

	defWriter.Write(gobig)
	defWriter.Close()

	dat := compressedDefs.Bytes()

	for i, b := range dat {
		if i%20 == 0 {
			fmt.Fprintf(file, "\n")
		}
		fmt.Fprintf(file, "0x%02X,", b)
	}

	fmt.Fprintf(file, "}")

	file.Close()
	entfile.Close()

	format(p)
	format(ep)
}

func runCommand(cmd string, args ...string) {
	c := exec.Command(cmd, args...)
	c.Stdout = os.Stdout
	c.Stdin = os.Stdin
	c.Run()
}

func format(path string) {
	runCommand("gofmt", "-w", path)
	runCommand("goimports", "-w", path)
}
