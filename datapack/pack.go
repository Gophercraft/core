// Package datapack allows users to extend Gophercraft with ease.
// It describes a simple format for loading data into Gophercraft and compatible clients
// Planned formats include:
//
//	3d objects/textures
//	Map geometry
//	Sound files
//	files for patching the server and client databases
package datapack

import (
	"io"
	"os"

	"github.com/Gophercraft/text"
)

type PackDependency struct {
	// The ID (found in PackInfo) to depend on
	ID string
	// The minimum acceptable version of this we depend on
	MinimumVersion uint32
}

type PackInfo struct {
	// the datapack's internal name "Gophercraft/example"
	ID string
	// The datapack's display name "Gophercraft Example Pack"
	Name string
	// Incremental version number of the pack itself
	Version uint32
	// SemVer of the required minimum Gophercraft Core version (x.x.x)
	MinimumCoreVersion string
	// The description of the datapack
	Description string
	// URL to the Git repository of the datapack "https://github.com/Gophercraft/example.git"
	Repository string
	// List your authors
	Authors []string
	// Is this a base datapack (something generated by the wizard?) If you are not sure, leave this false.
	Base bool
	// Dependencies
	Dependencies []PackDependency
	// Database tables to be overwritten
	OverrideTables []string
}

type Pack struct {
	info                    PackInfo
	reader                  reader
	dependencies            []*Pack
	transitive_dependencies []*Pack
}

func (pack *Pack) Open(path string) (file io.ReadCloser, err error) {
	return pack.reader.Open(path)
}

func (pack *Pack) List() (list []string) {
	list = pack.reader.List()
	return
}

func Open(path string) (pack *Pack, err error) {
	var fi os.FileInfo
	fi, err = os.Stat(path)
	if err != nil {
		return
	}

	var r reader

	if fi.IsDir() {
		r, err = open_directory(path)
	} else {
		r, err = open_archive(path)
	}

	if err != nil {
		return
	}

	pack = new(Pack)
	pack.reader = r

	var info_file io.ReadCloser
	info_file, err = pack.Open("Pack.txt")
	if err != nil {
		return
	}

	decoder := text.NewDecoder(info_file)
	err = decoder.Decode(&pack.info)
	if err != nil {
		return
	}

	info_file.Close()

	return
}

func (pack *Pack) Info() (pack_info *PackInfo) {
	return &pack.info
}
