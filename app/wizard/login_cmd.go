package wizard

import (
	"errors"
	"fmt"

	"github.com/Gophercraft/core/app/input"
	"github.com/Gophercraft/core/home/protocol/pb/account"
	"github.com/Gophercraft/core/home/protocol/pb/auth"
	"github.com/Gophercraft/core/wizard"
	"github.com/fatih/color"
	"github.com/spf13/cobra"
)

var login_cmd = &cobra.Command{
	Use:   "login",
	Short: "login to a Gophercraft Home server",
	Run:   login_func,
}

func login_func(cmd *cobra.Command, args []string) {
	if err := login(cmd, args); err != nil {
		printwarn(err)
	}
}

func display_key_attribute(depth int, col color.Attribute, key string, attribute any) {
	for i := 0; i < depth; i++ {
		fmt.Print(" ")
	}
	fmt.Printf("%s: ", key)
	color.Set(col)
	fmt.Printf("%v\n", attribute)
	color.Unset()
}

func display_account_status(status *account.AccountStatus) {
	fmt.Println("")
	fmt.Println("Account status:")
	display_key_attribute(1, color.FgWhite, "Name", status.Name)
	display_key_attribute(1, color.FgWhite, "ID", status.Id)
	display_key_attribute(1, color.FgWhite, "Tier", status.Tier.String())

}

func login(cmd *cobra.Command, args []string) (err error) {
	wiz := wizard.New()

	err = wiz.Init()

	if errors.Is(err, wizard.ErrDisconnected) {
		fmt.Println(err)
		err = nil
	} else if err != nil {
		return
	}

	if !wiz.Connected() {
		return fmt.Errorf("to log in to a Home server, you must first be connected to one\nUsage: gophercraft connect [home server address]")
	}

	if wiz.LoggedIn() {
		printfok("You are already logged in!\nRun 'gophercraft logout' to log out")
		return
	}

	var (
		account_name string
		password     string
	)

	account_name, password, err = input.ReadLogin()
	if err != nil {
		return
	}

	login_request := new(auth.LoginRequest)
	login_request.AccountName = account_name
	login_request.Password = password

	err = wiz.Login(login_request)
	if err != nil {
		return
	}

	var credential_status *auth.CredentialStatus
	credential_status, err = wiz.GetCredentialStatus()
	if err != nil {
		return
	}

	if credential_status.WebTokenStatus == auth.WebTokenStatus_AUTH_NEEDED {
		message := ""

		var methods *auth.TwoFactorAuthenticationMethodsResponse
		methods, err = wiz.GetTwoFactorAuthenticationMethods()
		if err != nil {
			return
		}

		if len(methods.Methods) == 0 {
			return fmt.Errorf("app/wizard: no authentication methods")
		}

		method := methods.Methods[0]

		switch method {
		case auth.TwoFactorAuthenticationMethod_EMAIL:
			message = "Enter the authentication code that was sent to your email inbox"
		case auth.TwoFactorAuthenticationMethod_TOTP:
			message = "Enter the code generated by your authenticator app"
		default:
			panic("unknown two-factor mechanism " + credential_status.TwoFactorAuthenticationMethod.String())
		}

		var authenticator_code string

		authenticator_code, err = input.ReadText(message, 16)
		if err != nil {
			return
		}

		if err = wiz.AuthenticateCredential(method, authenticator_code); err != nil {
			err = fmt.Errorf("authentication failed: %w", err)
			return
		}

		printfok("Authentication successful!")
	}

	var account_status *account.AccountStatus

	account_status, err = wiz.GetLoggedInAccountStatus()
	if err != nil {
		return
	}

	display_account_status(account_status)

	// Close the wizard
	wiz.Close()
	return
}
